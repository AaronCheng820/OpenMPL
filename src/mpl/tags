!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AlgorithmType	Enums.h	/^		AlgorithmType() : base_type() {m_value = enum_wrap_type::BACKTRACK;}$/;"	f	class:AlgorithmType
AlgorithmType	Enums.h	/^		AlgorithmType(AlgorithmType const& rhs) : base_type() {m_value = rhs.m_value;}$/;"	f	class:AlgorithmType
AlgorithmType	Enums.h	/^		AlgorithmType(enum_type const& rhs) : base_type() {m_value = rhs;}$/;"	f	class:AlgorithmType
AlgorithmType	Enums.h	/^		AlgorithmType(std::string const& rhs) : base_type() {m_value = str2Enum(rhs);}$/;"	f	class:AlgorithmType
AlgorithmType	Enums.h	/^class AlgorithmType : public EnumExt<AlgorithmTypeEnum::EnumType>$/;"	c
AlgorithmTypeEnum	Enums.h	/^struct AlgorithmTypeEnum$/;"	s
BACKTRACK	Enums.h	/^		BACKTRACK = 0,    \/\/ no dependency $/;"	e	enum:AlgorithmTypeEnum::EnumType
BOOST_REG_INTERSECTION	Makefile	/^BOOST_REG_INTERSECTION = 0$/;"	m
CSDP	Makefile	/^CSDP = 1$/;"	m
CXXFLAGS	Makefile	/^	CXXFLAGS = $(CXXFLAGS_DEBUG) -DDEBUG_LPCOLORING -DDEBUG_SDPCOLORING$/;"	m
CXXFLAGS	Makefile	/^	CXXFLAGS = $(CXXFLAGS_RELEASE) -DDEBUG_NONINTEGERS -DDEBUG_NOANCHOR$/;"	m
CmdParser	Params.h	/^	CmdParser(ControlParameter& p) : parms(p) {}$/;"	f	struct:CmdParser
CmdParser	Params.h	/^struct CmdParser$/;"	s
ControlParameter	Params.h	/^inline ControlParameter::ControlParameter()$/;"	f	class:ControlParameter
ControlParameter	Params.h	/^struct ControlParameter$/;"	s
DBG	Makefile	/^DBG = 0$/;"	m
DEPS	Makefile	/^DEPS = $(OBJS:%.o=%.d) 	# one dependency file for each source$/;"	m
ENUM2STR	Enums.cpp	13;"	d	file:
EXE	Makefile	/^EXE	= $(EXEDIR)\/OpenMPL$/;"	m
EXEDIR	Makefile	/^EXEDIR = $(PROGRAM_ROOT_DIR)\/bin$/;"	m
EnumExt	Enums.h	/^		EnumExt() {}$/;"	f	class:EnumExt
EnumExt	Enums.h	/^class EnumExt$/;"	c
EnumType	Enums.h	/^    enum EnumType {$/;"	g	struct:AlgorithmTypeEnum
EnumType	Enums.h	/^    enum EnumType {$/;"	g	struct:ShapeModeEnum
GPROF	Makefile	/^GPROF = 0$/;"	m
GUROBI	Makefile	/^GUROBI = 1$/;"	m
GUROBI	stitch/SimpleMPL.h	32;"	d
GdsReader	GdsiiIO.h	/^	GdsReader(layoutdb_type& _db) : db(_db) {}$/;"	f	struct:GdsReader
GdsReader	GdsiiIO.h	/^struct GdsReader : GdsParser::GdsDataBaseKernel$/;"	s
GdsWriter	GdsiiIO.h	/^struct GdsWriter$/;"	s
GenerateStitchPosition_Bei	SimpleMPL.cpp	/^void SimpleMPL::GenerateStitchPosition_Bei(const rectangle_type pRect, std::vector<rectangle_type> vInterSect, std::vector<coordinate_type> & vPossibleStitches,$/;"	f	class:SimpleMPL
GenerateStitchPosition_Jian	SimpleMPL.cpp	/^void SimpleMPL::GenerateStitchPosition_Jian(const rectangle_type pRect, std::vector<rectangle_type> vInterSect, std::vector<coordinate_type> & vPossibleStitches, $/;"	f	class:SimpleMPL
ILP_CBC	Enums.h	/^        ILP_CBC = 2,      \/\/ only valid when cbc is available$/;"	e	enum:AlgorithmTypeEnum::EnumType
ILP_GURBOI	Enums.h	/^		ILP_GURBOI = 1,   \/\/ only valid when gurobi is available$/;"	e	enum:AlgorithmTypeEnum::EnumType
INCLUDE	Makefile	/^INCLUDE = \\$/;"	m
LEMONCBC	Makefile	/^LEMONCBC = 0$/;"	m
LIB	Makefile	/^LIB = $(LIBDIR)\/OpenMPL.a$/;"	m
LIBDIR	Makefile	/^LIBDIR = $(PROGRAM_ROOT_DIR)\/lib$/;"	m
LIBS	Makefile	/^LIBS = $(STATIC_LINK_FLAG) \\$/;"	m
LP_GUROBI	Enums.h	/^        LP_GUROBI = 3,    \/\/ only valid when gurobi is available$/;"	e	enum:AlgorithmTypeEnum::EnumType
LayoutDB	LayoutDB.cpp	/^LayoutDB::LayoutDB() $/;"	f	class:LayoutDB
LayoutDB	LayoutDB.cpp	/^LayoutDB::LayoutDB(LayoutDB const& rhs) $/;"	f	class:LayoutDB
LayoutDB	LayoutDB.cpp	/^LayoutDB::LayoutDB(LayoutDB::coordinate_type xl, LayoutDB::coordinate_type yl, LayoutDB::coordinate_type xh, LayoutDB::coordinate_type yh) $/;"	f	class:LayoutDB
LayoutDB	LayoutDB.h	/^struct LayoutDB : public rectangle_data<int32_t>$/;"	s
LayoutDBPolygon	LayoutDBPolygon.cpp	/^LayoutDBPolygon::LayoutDBPolygon() : LayoutDBPolygon::base_type() $/;"	f	class:LayoutDBPolygon
LayoutDBPolygon	LayoutDBPolygon.cpp	/^LayoutDBPolygon::LayoutDBPolygon(LayoutDBPolygon const& rhs) : LayoutDBPolygon::base_type(rhs)$/;"	f	class:LayoutDBPolygon
LayoutDBPolygon	LayoutDBPolygon.cpp	/^LayoutDBPolygon::LayoutDBPolygon(LayoutDBPolygon::coordinate_type xl, LayoutDBPolygon::coordinate_type yl, LayoutDBPolygon::coordinate_type xh, LayoutDBPolygon::coordinate_type yh) $/;"	f	class:LayoutDBPolygon
LayoutDBPolygon	LayoutDBPolygon.h	/^struct LayoutDBPolygon : public LayoutDB$/;"	s
LayoutDBRect	LayoutDBRect.cpp	/^LayoutDBRect::LayoutDBRect() : LayoutDBRect::base_type() $/;"	f	class:LayoutDBRect
LayoutDBRect	LayoutDBRect.cpp	/^LayoutDBRect::LayoutDBRect(LayoutDBRect const& rhs) : LayoutDBRect::base_type(rhs)$/;"	f	class:LayoutDBRect
LayoutDBRect	LayoutDBRect.cpp	/^LayoutDBRect::LayoutDBRect(LayoutDBRect::coordinate_type xl, LayoutDBRect::coordinate_type yl, LayoutDBRect::coordinate_type xh, LayoutDBRect::coordinate_type yh) $/;"	f	class:LayoutDBRect
LayoutDBRect	LayoutDBRect.h	/^struct LayoutDBRect : public LayoutDB$/;"	s
MINDPLDIST	stitch/StitchProc.h	/^	double MINDPLDIST			= 0;		\/\/ minimual DPL distance$/;"	m	class:StitchProc
MIS_GUROBI	Enums.h	/^        MIS_GUROBI = 5    \/\/ only valid when gurobi is available $/;"	e	enum:AlgorithmTypeEnum::EnumType
MKDIR	Makefile	/^MKDIR = if [ ! -d $(@D) ]; then mkdir -p $(@D); fi$/;"	m
MessageType	Msg.h	/^enum MessageType {$/;"	g
OBJDIR	Makefile	/^OBJDIR = $(PROGRAM_ROOT_DIR)\/obj$/;"	m
OBJS	Makefile	/^OBJS = $(SRCS:%.cpp=$(OBJDIR)\/%.o)$/;"	m
OBJS_NOMAIN	Makefile	/^OBJS_NOMAIN = $(filter-out $(OBJDIR)\/main.o, $(OBJS)) # filter out main.o $/;"	m
PITCH	stitch/StitchProc.h	/^	double PITCH				= 0;		\/\/ still not sure whether use pitch in this problem $/;"	m	class:StitchProc
POLYGON	Enums.h	/^        POLYGON = 1 \/\/ contain polygons or overlapping rectangles $/;"	e	enum:ShapeModeEnum::EnumType
PROGRAM_ROOT_DIR	Makefile	/^PROGRAM_ROOT_DIR = ..\/..$/;"	m
Polygon	Shapes.h	/^		Polygon() : base_type(), shape_base_type() {}$/;"	f	class:Polygon
Polygon	Shapes.h	/^		Polygon(Polygon const& rhs) : base_type(rhs), shape_base_type(rhs) {}$/;"	f	class:Polygon
Polygon	Shapes.h	/^class Polygon : public polygon_90_data<T>, public Shape$/;"	c
QiBox	stitch/SimpleMPL.h	/^	struct QiBox{$/;"	s
QiPoint	stitch/SimpleMPL.h	/^	struct QiPoint$/;"	s
RECTANGLE	Enums.h	/^        RECTANGLE = 0, \/\/ only non-overlapping rectangles $/;"	e	enum:ShapeModeEnum::EnumType
RecoverHiddenVertex	RecoverHiddenVertex.cpp	/^RecoverHiddenVertex::RecoverHiddenVertex(RecoverHiddenVertex::graph_type const& dg, std::vector<uint32_t>::const_iterator itBgn, uint32_t pattern_cnt, $/;"	f	class:RecoverHiddenVertex
RecoverHiddenVertex	RecoverHiddenVertex.h	/^class RecoverHiddenVertex$/;"	c
RecoverHiddenVertexDistance	RecoverHiddenVertex.cpp	/^RecoverHiddenVertexDistance::RecoverHiddenVertexDistance(RecoverHiddenVertexDistance::graph_type const& dg, std::vector<uint32_t>::const_iterator itBgn, uint32_t pattern_cnt, $/;"	f	class:RecoverHiddenVertexDistance
RecoverHiddenVertexDistance	RecoverHiddenVertex.h	/^class RecoverHiddenVertexDistance : public RecoverHiddenVertex$/;"	c
RecoverHiddenVertexImageContrast	RecoverHiddenVertex.cpp	/^RecoverHiddenVertexImageContrast::RecoverHiddenVertexImageContrast(RecoverHiddenVertexImageContrast::graph_type const& dg, std::vector<uint32_t>::const_iterator itBgn, uint32_t pattern_cnt, $/;"	f	class:RecoverHiddenVertexImageContrast
RecoverHiddenVertexImageContrast	RecoverHiddenVertex.h	/^class RecoverHiddenVertexImageContrast : public RecoverHiddenVertex$/;"	c
Rectangle	Shapes.h	/^		Rectangle() : base_type(), shape_base_type() {}$/;"	f	class:Rectangle
Rectangle	Shapes.h	/^		Rectangle(Rectangle const& rhs) : base_type(rhs), shape_base_type(rhs) {}$/;"	f	class:Rectangle
Rectangle	Shapes.h	/^		Rectangle(coordinate_type xl, coordinate_type yl, coordinate_type xh, coordinate_type yh) : base_type(xl, yl, xh, yh), shape_base_type() {}$/;"	f	class:Rectangle
Rectangle	Shapes.h	/^		Rectangle(interval_type const& hor, interval_type const& ver) : base_type(hor, ver), shape_base_type() {}$/;"	f	class:Rectangle
Rectangle	Shapes.h	/^class Rectangle : public rectangle_data<T>, public Shape$/;"	c
SDP_CSDP	Enums.h	/^        SDP_CSDP = 4,     \/\/ only valid when Csdp is available$/;"	e	enum:AlgorithmTypeEnum::EnumType
SIMPLEMPL_BEGIN_NAMESPACE	Namespace.h	12;"	d
SIMPLEMPL_END_NAMESPACE	Namespace.h	13;"	d
SIMPLEMPL_ENUMS_H	Enums.h	9;"	d
SIMPLEMPL_GDSIIIO_H	GdsiiIO.h	9;"	d
SIMPLEMPL_GEOMETRYAPI_H	GeometryApi.h	9;"	d
SIMPLEMPL_LAYOUTDBPOLYGON_H	LayoutDBPolygon.h	9;"	d
SIMPLEMPL_LAYOUTDBRECT_H	LayoutDBRect.h	9;"	d
SIMPLEMPL_LAYOUTDB_H	LayoutDB.h	9;"	d
SIMPLEMPL_MSG_H	Msg.h	9;"	d
SIMPLEMPL_NAMESPACE	Namespace.h	11;"	d
SIMPLEMPL_NAMESPACE_H	Namespace.h	9;"	d
SIMPLEMPL_PARMS_H	Params.h	9;"	d
SIMPLEMPL_RECOVERHIDDENVERTEX_H	RecoverHiddenVertex.h	9;"	d
SIMPLEMPL_SHAPES_H	Shapes.h	9;"	d
SIMPLEMPL_SIMPLEMPL_H	SimpleMPL.h	9;"	d
SIMPLEMPL_SIMPLEMPL_H	stitch/SimpleMPL.h	9;"	d
SRCS	Makefile	/^SRCS = $(wildcard *.cpp)$/;"	m
STR2ENUM	Enums.cpp	18;"	d	file:
Shape	Shapes.h	/^		Shape() {this->initialize();}$/;"	f	class:Shape
Shape	Shapes.h	/^		Shape(Shape const& rhs) {this->copy(rhs);}$/;"	f	class:Shape
Shape	Shapes.h	/^class Shape $/;"	c
ShapeMode	Enums.h	/^		ShapeMode() : base_type() {m_value = enum_wrap_type::RECTANGLE;}$/;"	f	class:ShapeMode
ShapeMode	Enums.h	/^		ShapeMode(ShapeMode const& rhs) : base_type() {m_value = rhs.m_value;}$/;"	f	class:ShapeMode
ShapeMode	Enums.h	/^		ShapeMode(enum_type const& rhs) : base_type() {m_value = rhs;}$/;"	f	class:ShapeMode
ShapeMode	Enums.h	/^		ShapeMode(std::string const& rhs) : base_type() {m_value = str2Enum(rhs);}$/;"	f	class:ShapeMode
ShapeMode	Enums.h	/^class ShapeMode : public EnumExt<ShapeModeEnum::EnumType>$/;"	c
ShapeModeEnum	Enums.h	/^struct ShapeModeEnum$/;"	s
SimpleMPL	SimpleMPL.cpp	/^SimpleMPL::SimpleMPL()$/;"	f	class:SimpleMPL
SimpleMPL	SimpleMPL.h	/^class SimpleMPL$/;"	c
SimpleMPL	stitch/SimpleMPL.cpp	/^SimpleMPL::SimpleMPL()$/;"	f	class:SimpleMPL
SimpleMPL	stitch/SimpleMPL.h	/^class SimpleMPL$/;"	c
SplitMapping	SimpleMPL.h	/^	std::vector<std::vector<uint32_t> > SplitMapping;	\/\/ stores the mapping relationships between original patterns and newly-generated patterns.$/;"	m	class:SimpleMPL
SplitMapping	stitch/SimpleMPL.h	/^		std::vector<std::vector<uint32_t> > SplitMapping; \/\/ stores the mapping relationships between original patterns and newly - generated patterns.$/;"	m	class:SimpleMPL
StitchGenerateDPL_Points	stitch/StitchProc.cpp	/^void StitchProc::StitchGenerateDPL_Points(const rectangle_pointer_type pRect, const std::vector<rectangle_pointer_type> vinterRect, std::vector <coordinate_type> vstitches, coordinate_type left, coordinate_type right, bool vddstitch = false)$/;"	f	class:StitchProc
StitchGenerateTPL_Points	stitch/StitchProc.cpp	/^void StitchProc::StitchGenerateTPL_Points(const rectangle_pointer_type pRect, const std::vector<rectangle_pointer_type> vinterRect, std::vector <coordinate_type> vstitches, coordinate_type left, coordinate_type right, bool vddstitch = false)$/;"	f	class:StitchProc
StitchProc	stitch/StitchProc.cpp	/^StitchProc::StitchProc()$/;"	f	class:StitchProc
StitchProc	stitch/StitchProc.cpp	/^StitchProc::StitchProc(double pitch)$/;"	f	class:StitchProc
StitchProc	stitch/StitchProc.h	/^class StitchProc $/;"	c
UNAME_S	Makefile	/^UNAME_S = $(shell uname -s)$/;"	m
V	GeometryApi.h	/^    typedef Box* V;$/;"	t	struct:boost::geometry::index::indexable
V	GeometryApi.h	/^    typedef boost::shared_ptr<Box> V;$/;"	t	struct:boost::geometry::index::indexable
_STITCHPROC_H_	stitch/StitchProc.h	10;"	d
add	LayoutDB.cpp	/^void LayoutDB::add(int32_t layer, std::vector<point_type> const& vPoint)$/;"	f	class:LayoutDB
add_path	LayoutDB.cpp	/^void LayoutDB::add_path(int32_t layer, std::vector<point_type> const& vPoint)$/;"	f	class:LayoutDB
add_pattern	LayoutDBPolygon.cpp	/^void LayoutDBPolygon::add_pattern(int32_t layer, std::vector<point_type> const& vPoint)$/;"	f	class:LayoutDBPolygon
add_pattern	LayoutDBRect.cpp	/^void LayoutDBRect::add_pattern(int32_t layer, std::vector<point_type> const& vPoint)$/;"	f	class:LayoutDBRect
adj4NewPatterns	SimpleMPL.cpp	/^void SimpleMPL::adj4NewPatterns(std::vector<std::vector<rectangle_pointer_type> > & m_mSplitPatternBbox, std::vector<std::vector<uint32_t> > & new_mAdjVertex)$/;"	f	class:SimpleMPL
algo	LayoutDB.h	/^    inline AlgorithmType algo() const {return parms.algo;}$/;"	f	struct:LayoutDB
algo	Params.h	/^	AlgorithmType algo;                        \/\/\/< control algorithms used to solve coloring problem $/;"	m	struct:ControlParameter
area_type	LayoutDB.h	/^	typedef gtl::coordinate_traits<coordinate_type>::manhattan_area_type area_type;$/;"	t	struct:LayoutDB
base_type	Enums.h	/^        typedef EnumExt<enum_type> base_type;$/;"	t	class:AlgorithmType
base_type	Enums.h	/^        typedef EnumExt<enum_type> base_type;$/;"	t	class:ShapeMode
base_type	LayoutDB.h	/^	typedef rectangle_data<coordinate_type> base_type;$/;"	t	struct:LayoutDB
base_type	LayoutDBPolygon.h	/^    typedef LayoutDB base_type;$/;"	t	struct:LayoutDBPolygon
base_type	LayoutDBRect.h	/^    typedef LayoutDB base_type;$/;"	t	struct:LayoutDBRect
base_type	RecoverHiddenVertex.h	/^        typedef RecoverHiddenVertex base_type;$/;"	t	class:RecoverHiddenVertexDistance
base_type	RecoverHiddenVertex.h	/^        typedef RecoverHiddenVertex base_type;$/;"	t	class:RecoverHiddenVertexImageContrast
base_type	Shapes.h	/^		typedef polygon_90_data<coordinate_type> base_type;$/;"	t	class:Polygon
base_type	Shapes.h	/^		typedef rectangle_data<coordinate_type> base_type;$/;"	t	class:Rectangle
begin_end_cbk	GdsiiIO.cpp	/^void GdsReader::begin_end_cbk(GdsParser::GdsRecords::EnumType record_type)$/;"	f	class:GdsReader
begin_lib	LayoutDB.h	/^	virtual void begin_lib() {}$/;"	f	struct:LayoutDB
begin_str	LayoutDB.h	/^	virtual void begin_str() {}$/;"	f	struct:LayoutDB
bit_array_cbk	GdsiiIO.cpp	/^void GdsReader::bit_array_cbk(GdsParser::GdsRecords::EnumType record_type, GdsParser::GdsData::EnumType data_type, std::vector<int> const& vBitArray)$/;"	f	class:GdsReader
boost	GeometryApi.h	/^namespace boost { namespace geometry { namespace index {$/;"	n
boost	GeometryApi.h	/^namespace boost { namespace geometry { namespace traits {$/;"	n
boost	GeometryApi.h	/^namespace boost { namespace polygon {$/;"	n
boost	Shapes.h	/^namespace boost { namespace polygon {$/;"	n
check_layer_and_color	LayoutDB.cpp	/^void LayoutDB::check_layer_and_color(int32_t layer, bool& pattern_layer_flag, int8_t& color) const$/;"	f	class:LayoutDB
check_uncolored	SimpleMPL.cpp	/^bool SimpleMPL::check_uncolored(std::vector<uint32_t>::const_iterator itBgn, std::vector<uint32_t>::const_iterator itEnd) const$/;"	f	class:SimpleMPL
check_uncolored	stitch/SimpleMPL.cpp	/^bool SimpleMPL::check_uncolored(std::vector<uint32_t>::const_iterator itBgn, std::vector<uint32_t>::const_iterator itEnd) const$/;"	f	class:SimpleMPL
color	Shapes.h	/^		int8_t color() const {return m_color;}$/;"	f	class:Shape
color	Shapes.h	/^		void color(int8_t c) {m_color = c;}$/;"	f	class:Shape
color_num	LayoutDB.h	/^	inline int32_t color_num() const { return parms.color_num; }$/;"	f	struct:LayoutDB
color_num	Params.h	/^	int32_t color_num;                         \/\/\/< number of colors available, only support 3 or 4$/;"	m	struct:ControlParameter
coloring_component	SimpleMPL.cpp	/^uint32_t SimpleMPL::coloring_component(const std::vector<uint32_t>::const_iterator itBgn, const std::vector<uint32_t>::const_iterator itEnd, uint32_t comp_id)$/;"	f	class:SimpleMPL
coloring_component	stitch/SimpleMPL.cpp	/^uint32_t SimpleMPL::coloring_component(const std::vector<uint32_t>::const_iterator itBgn, const std::vector<uint32_t>::const_iterator itEnd, uint32_t comp_id)$/;"	f	class:SimpleMPL
coloring_distance	LayoutDB.h	/^	coordinate_difference coloring_distance;   \/\/\/< minimum coloring distance, set from coloring_distance_nm and unit$/;"	m	struct:LayoutDB
coloring_distance_nm	LayoutDB.h	/^	inline double coloring_distance_nm() const { return parms.coloring_distance_nm; }$/;"	f	struct:LayoutDB
coloring_distance_nm	Params.h	/^	double coloring_distance_nm;               \/\/\/< minimum coloring distance in nanometer, set from command line $/;"	m	struct:ControlParameter
compare_rectangle_type	LayoutDB.h	/^	struct compare_rectangle_type$/;"	s	struct:LayoutDB
compute_parent_polygon_bboxes	LayoutDBPolygon.cpp	/^void LayoutDBPolygon::compute_parent_polygon_bboxes(uint32_t num_polygons)$/;"	f	class:LayoutDBPolygon
compute_parent_polygons	LayoutDBPolygon.cpp	/^void LayoutDBPolygon::compute_parent_polygons()$/;"	f	class:LayoutDBPolygon
conflict_num	SimpleMPL.cpp	/^uint32_t SimpleMPL::conflict_num() const$/;"	f	class:SimpleMPL
conflict_num	SimpleMPL.cpp	/^uint32_t SimpleMPL::conflict_num(const std::vector<uint32_t>::const_iterator itBgn, const std::vector<uint32_t>::const_iterator itEnd) const$/;"	f	class:SimpleMPL
conflict_num	stitch/SimpleMPL.cpp	/^uint32_t SimpleMPL::conflict_num() const$/;"	f	class:SimpleMPL
conflict_num	stitch/SimpleMPL.cpp	/^uint32_t SimpleMPL::conflict_num(const std::vector<uint32_t>::const_iterator itBgn, const std::vector<uint32_t>::const_iterator itEnd) const$/;"	f	class:SimpleMPL
connected_component	SimpleMPL.cpp	/^void SimpleMPL::connected_component()$/;"	f	class:SimpleMPL
connected_component	stitch/SimpleMPL.cpp	/^void SimpleMPL::connected_component()$/;"	f	class:SimpleMPL
construct	GeometryApi.h	/^	static rectangle_type construct(coordinate_type const& xl, coordinate_type const& yl, $/;"	f	struct:limbo::geometry::rectangle_traits
construct_component_graph	SimpleMPL.cpp	/^void SimpleMPL::construct_component_graph(const std::vector<uint32_t>::const_iterator itBgn, uint32_t const pattern_cnt,$/;"	f	class:SimpleMPL
construct_component_graph	stitch/SimpleMPL.cpp	/^void SimpleMPL::construct_component_graph(const std::vector<uint32_t>::const_iterator itBgn, uint32_t const pattern_cnt, $/;"	f	class:SimpleMPL
construct_graph	SimpleMPL.cpp	/^void SimpleMPL::construct_graph()$/;"	f	class:SimpleMPL
construct_graph	stitch/SimpleMPL.cpp	/^void SimpleMPL::construct_graph()$/;"	f	class:SimpleMPL
construct_graph_from_distance	SimpleMPL.cpp	/^uint32_t SimpleMPL::construct_graph_from_distance(uint32_t vertex_num)$/;"	f	class:SimpleMPL
construct_graph_from_distance	stitch/SimpleMPL.cpp	/^uint32_t SimpleMPL::construct_graph_from_distance(uint32_t vertex_num)$/;"	f	class:SimpleMPL
construct_graph_from_paths	SimpleMPL.cpp	/^uint32_t SimpleMPL::construct_graph_from_paths(uint32_t vertex_num)$/;"	f	class:SimpleMPL
construct_graph_from_paths	stitch/SimpleMPL.cpp	/^uint32_t SimpleMPL::construct_graph_from_paths(uint32_t vertex_num)$/;"	f	class:SimpleMPL
coordinate_difference	LayoutDB.h	/^	typedef gtl::coordinate_traits<coordinate_type>::coordinate_difference coordinate_difference;$/;"	t	struct:LayoutDB
coordinate_difference	RecoverHiddenVertex.h	/^        typedef layoutdb_type::coordinate_difference   coordinate_difference;$/;"	t	class:RecoverHiddenVertex
coordinate_difference	SimpleMPL.h	/^	typedef layoutdb_type::coordinate_difference   coordinate_difference;$/;"	t	class:SimpleMPL
coordinate_difference	stitch/SimpleMPL.h	/^        typedef layoutdb_type::coordinate_difference   coordinate_difference;$/;"	t	class:SimpleMPL
coordinate_difference	stitch/StitchProc.h	/^	typedef layoutdb_type::coordinate_difference   coordinate_difference;$/;"	t	class:StitchProc
coordinate_type	GdsiiIO.h	/^	typedef layoutdb_type::coordinate_type coordinate_type;$/;"	t	struct:GdsReader
coordinate_type	GdsiiIO.h	/^    typedef layoutdb_type::coordinate_type coordinate_type;$/;"	t	struct:GdsWriter
coordinate_type	GeometryApi.h	/^	typedef T coordinate_type;$/;"	t	struct:limbo::geometry::rectangle_traits
coordinate_type	LayoutDB.h	/^	typedef int32_t coordinate_type;$/;"	t	struct:LayoutDB
coordinate_type	LayoutDBPolygon.h	/^	typedef base_type::coordinate_type coordinate_type;$/;"	t	struct:LayoutDBPolygon
coordinate_type	LayoutDBRect.h	/^	typedef base_type::coordinate_type coordinate_type;$/;"	t	struct:LayoutDBRect
coordinate_type	RecoverHiddenVertex.h	/^        typedef layoutdb_type::coordinate_type coordinate_type;$/;"	t	class:RecoverHiddenVertex
coordinate_type	Shapes.h	/^		typedef T coordinate_type;$/;"	t	class:Polygon
coordinate_type	Shapes.h	/^		typedef T coordinate_type;$/;"	t	class:Rectangle
coordinate_type	SimpleMPL.h	/^	typedef layoutdb_type::coordinate_type coordinate_type;$/;"	t	class:SimpleMPL
coordinate_type	stitch/SimpleMPL.h	/^        typedef layoutdb_type::coordinate_type coordinate_type;$/;"	t	class:SimpleMPL
coordinate_type	stitch/StitchProc.h	/^	typedef layoutdb_type::coordinate_type coordinate_type;$/;"	t	class:StitchProc
copy	LayoutDB.cpp	/^void LayoutDB::copy(LayoutDB const& rhs)$/;"	f	class:LayoutDB
copy	LayoutDBPolygon.cpp	/^void LayoutDBPolygon::copy(LayoutDBPolygon const& rhs)$/;"	f	class:LayoutDBPolygon
copy	LayoutDBRect.cpp	/^void LayoutDBRect::copy(LayoutDBRect const&)$/;"	f	class:LayoutDBRect
copy	Shapes.h	/^		void copy(Shape const& rhs)$/;"	f	class:Shape
create_coloring_solver	SimpleMPL.cpp	/^lac::Coloring<SimpleMPL::graph_type>* SimpleMPL::create_coloring_solver(SimpleMPL::graph_type const& sg) const$/;"	f	class:SimpleMPL
create_coloring_solver	stitch/SimpleMPL.cpp	/^lac::Coloring<SimpleMPL::graph_type>* SimpleMPL::create_coloring_solver(SimpleMPL::graph_type const& sg) const$/;"	f	class:SimpleMPL
db	GdsiiIO.h	/^	layoutdb_type& db;  $/;"	m	struct:GdsReader
dbg_comp_id	LayoutDB.h	/^    inline uint32_t dbg_comp_id() const {return parms.dbg_comp_id;}$/;"	f	struct:LayoutDB
dbg_comp_id	Params.h	/^    uint32_t dbg_comp_id;                      \/\/\/< component id for debug, if matched, graphs will be dumped before and after coloring  $/;"	m	struct:ControlParameter
depth_first_search	LayoutDBPolygon.cpp	/^void LayoutDBPolygon::depth_first_search(uint32_t source, uint32_t polygon_id, uint32_t& order_id, std::vector<uint32_t>& vOrderId)$/;"	f	class:LayoutDBPolygon
depth_first_search	SimpleMPL.cpp	/^void SimpleMPL::depth_first_search(uint32_t source, uint32_t comp_id, uint32_t& order_id)$/;"	f	class:SimpleMPL
depth_first_search	stitch/SimpleMPL.cpp	/^void SimpleMPL::depth_first_search(uint32_t source, uint32_t comp_id, uint32_t& order_id)$/;"	f	class:SimpleMPL
dplstitch	stitch/StitchProc.h	/^	bool dplstitch				= true;		\/\/ whether use DPL method to generate stitch candidates, if false, then use TPL method.$/;"	m	class:StitchProc
edge_descriptor	LayoutDB.h	/^	typedef boost::graph_traits<graph_type>::edge_descriptor edge_descriptor;$/;"	t	struct:LayoutDB
edge_descriptor	RecoverHiddenVertex.h	/^        typedef layoutdb_type::edge_descriptor         edge_descriptor;$/;"	t	class:RecoverHiddenVertex
edge_descriptor	SimpleMPL.h	/^	typedef layoutdb_type::edge_descriptor         edge_descriptor;$/;"	t	class:SimpleMPL
edge_descriptor	stitch/SimpleMPL.h	/^        typedef layoutdb_type::edge_descriptor         edge_descriptor;$/;"	t	class:SimpleMPL
edge_descriptor	stitch/StitchProc.h	/^	typedef layoutdb_type::edge_descriptor         edge_descriptor;$/;"	t	class:StitchProc
end_lib	LayoutDB.h	/^	virtual void end_lib() {}$/;"	f	struct:LayoutDB
end_str	LayoutDB.h	/^	virtual void end_str() {}$/;"	f	struct:LayoutDB
enum2Str	Enums.cpp	/^std::string AlgorithmType::enum2Str(AlgorithmType::enum_type const& e) const$/;"	f	class:AlgorithmType
enum2Str	Enums.cpp	/^std::string ShapeMode::enum2Str(ShapeMode::enum_type const& e) const$/;"	f	class:ShapeMode
enum_type	Enums.h	/^        typedef EnumType enum_type;$/;"	t	class:EnumExt
enum_type	Enums.h	/^        typedef enum_wrap_type::EnumType enum_type;$/;"	t	class:AlgorithmType
enum_type	Enums.h	/^        typedef enum_wrap_type::EnumType enum_type;$/;"	t	class:ShapeMode
enum_wrap_type	Enums.h	/^        typedef AlgorithmTypeEnum enum_wrap_type;$/;"	t	class:AlgorithmType
enum_wrap_type	Enums.h	/^        typedef ShapeModeEnum enum_wrap_type;$/;"	t	class:ShapeMode
euclidean_distance	GeometryApi.h	/^  euclidean_distance(const SimpleMPL::Rectangle<T> & lvalue, const SimpleMPL::Rectangle<T>& rvalue) {$/;"	f	namespace:boost::polygon
euclidean_distance	LayoutDBPolygon.cpp	/^LayoutDBPolygon::coordinate_difference LayoutDBPolygon::euclidean_distance(rectangle_type const& r1, rectangle_type const& r2) const $/;"	f	class:LayoutDBPolygon
euclidean_distance	LayoutDBRect.h	/^    virtual coordinate_difference euclidean_distance(rectangle_type const& r1, rectangle_type const& r2) const {return gtl::euclidean_distance(r1, r2);}$/;"	f	struct:LayoutDBRect
file_size	GdsiiIO.h	/^	int64_t file_size; \/\/ in bytes $/;"	m	struct:GdsReader
find_best_color	RecoverHiddenVertex.cpp	/^int8_t RecoverHiddenVertex::find_best_color(RecoverHiddenVertex::vertex_descriptor \/*v*\/) $/;"	f	class:RecoverHiddenVertex
find_best_color	RecoverHiddenVertex.cpp	/^int8_t RecoverHiddenVertexDistance::find_best_color(RecoverHiddenVertexDistance::vertex_descriptor v) $/;"	f	class:RecoverHiddenVertexDistance
find_best_color	RecoverHiddenVertex.cpp	/^int8_t RecoverHiddenVertexImageContrast::find_best_color(RecoverHiddenVertexImageContrast::vertex_descriptor \/*v*\/)$/;"	f	class:RecoverHiddenVertexImageContrast
find_unused_colors	RecoverHiddenVertex.cpp	/^void RecoverHiddenVertex::find_unused_colors(RecoverHiddenVertex::vertex_descriptor v)$/;"	f	class:RecoverHiddenVertex
float_cbk	GdsiiIO.cpp	/^void GdsReader::float_cbk(GdsParser::GdsRecords::EnumType record_type, GdsParser::GdsData::EnumType data_type, std::vector<double> const& vData)$/;"	f	class:GdsReader
gen_stitch	LayoutDB.h	/^	inline bool gen_stitch() const { return parms.gen_stitch; }$/;"	f	struct:LayoutDB
gen_stitch	Params.h	/^    bool gen_stitch;                           \/\/\/< control stitch generation$/;"	m	struct:ControlParameter
generate_id	Shapes.h	/^		static long generate_id()$/;"	f	class:Shape
geometry	GeometryApi.h	/^namespace boost { namespace geometry { namespace index {$/;"	n	namespace:boost
geometry	GeometryApi.h	/^namespace boost { namespace geometry { namespace traits {$/;"	n	namespace:boost
geometry	GeometryApi.h	/^namespace limbo { namespace geometry {$/;"	n	namespace:limbo
geometry_concept	GeometryApi.h	/^struct geometry_concept<SimpleMPL::LayoutDB> $/;"	s	namespace:boost::polygon
geometry_concept	GeometryApi.h	/^struct geometry_concept<SimpleMPL::LayoutDBPolygon> $/;"	s	namespace:boost::polygon
geometry_concept	GeometryApi.h	/^struct geometry_concept<SimpleMPL::LayoutDBRect> $/;"	s	namespace:boost::polygon
geometry_concept	GeometryApi.h	/^struct geometry_concept<SimpleMPL::Rectangle<T> > $/;"	s	namespace:boost::polygon
geometry_type	Shapes.h	/^		typedef rectangle_concept geometry_type; \/\/ important $/;"	t	class:Rectangle
get	Enums.h	/^        EnumType const& get() const {return m_value;}$/;"	f	class:EnumExt
get	GeometryApi.h	/^	static coordinate_type get(const typename rectangle_type::base_type& rect, direction_2d const& dir) $/;"	f	struct:limbo::geometry::rectangle_traits
getHeight	stitch/StitchProc.h	/^	coordinate_type getHeight(rectangle_pointer_type rect) { return gtl::yh(*rect) - gtl::yl(*rect); }$/;"	f	class:StitchProc
getWidth	stitch/StitchProc.h	/^	coordinate_type getWidth(rectangle_pointer_type rect) { return gtl::xh(*rect) - gtl::xl(*rect); }$/;"	f	class:StitchProc
get_point_closest_to_center	LayoutDBPolygon.cpp	/^LayoutDBPolygon::point_type LayoutDBPolygon::get_point_closest_to_center(uint32_t pattern_id) const$/;"	f	class:LayoutDBPolygon
get_point_closest_to_center	LayoutDBRect.cpp	/^LayoutDBRect::point_type LayoutDBRect::get_point_closest_to_center(uint32_t pattern_id) const$/;"	f	class:LayoutDBRect
graph_type	LayoutDB.h	/^	> graph_type;$/;"	t	struct:LayoutDB
graph_type	RecoverHiddenVertex.h	/^        typedef layoutdb_type::graph_type              graph_type;$/;"	t	class:RecoverHiddenVertex
graph_type	SimpleMPL.h	/^	typedef layoutdb_type::graph_type              graph_type;$/;"	t	class:SimpleMPL
graph_type	stitch/SimpleMPL.h	/^        typedef layoutdb_type::graph_type              graph_type;$/;"	t	class:SimpleMPL
graph_type	stitch/StitchProc.h	/^	typedef layoutdb_type::graph_type              graph_type;$/;"	t	class:StitchProc
hPath	LayoutDB.h	/^	std::map<int32_t, std::vector<path_type> > hPath;    \/\/\/< path that indicates conflict edges from input$/;"	m	struct:LayoutDB
index	GeometryApi.h	/^namespace boost { namespace geometry { namespace index {$/;"	n	namespace:boost::geometry
indexable	GeometryApi.h	/^struct indexable< Box* >$/;"	s	namespace:boost::geometry::index
indexable	GeometryApi.h	/^struct indexable< boost::shared_ptr<Box> >$/;"	s	namespace:boost::geometry::index
indexed_access	GeometryApi.h	/^struct indexed_access$/;"	s	namespace:boost::geometry::traits
initialize	LayoutDB.cpp	/^void LayoutDB::initialize()$/;"	f	class:LayoutDB
initialize	Shapes.h	/^		void initialize()$/;"	f	class:Shape
initialize_data	LayoutDB.cpp	/^void LayoutDB::initialize_data()$/;"	f	class:LayoutDB
initialize_data	LayoutDBPolygon.cpp	/^void LayoutDBPolygon::initialize_data()$/;"	f	class:LayoutDBPolygon
initialize_data	LayoutDBRect.cpp	/^void LayoutDBRect::initialize_data()$/;"	f	class:LayoutDBRect
input_gds	LayoutDB.h	/^    inline std::string const& input_gds() const {return parms.input_gds;}$/;"	f	class:LayoutDB::std
input_gds	Params.h	/^	std::string   input_gds;                   \/\/\/< input gdsii filename $/;"	m	struct:ControlParameter
integer_2_cbk	GdsiiIO.cpp	/^void GdsReader::integer_2_cbk(GdsParser::GdsRecords::EnumType record_type, GdsParser::GdsData::EnumType data_type, std::vector<int> const& vInteger)$/;"	f	class:GdsReader
integer_4_cbk	GdsiiIO.cpp	/^void GdsReader::integer_4_cbk(GdsParser::GdsRecords::EnumType record_type, GdsParser::GdsData::EnumType data_type, std::vector<int> const& vInteger)$/;"	f	class:GdsReader
integer_cbk	GdsiiIO.cpp	/^void GdsReader::integer_cbk(GdsParser::GdsRecords::EnumType record_type, GdsParser::GdsData::EnumType \/*data_type*\/, std::vector<int> const& vData)$/;"	f	class:GdsReader
interSectionRect	SimpleMPL.cpp	/^LayoutDB::rectangle_type SimpleMPL::interSectionRect(rectangle_type rect1, rectangle_type rect2)$/;"	f	class:SimpleMPL
interSectionRectBoost	stitch/SimpleMPL.h	/^	LayoutDB::rectangle_type interSectionRectBoost(LayoutDB::rectangle_type rect1, LayoutDB::rectangle_type QRectangle rect2)$/;"	f
internal_id	Shapes.h	/^		long internal_id() {return m_internal_id;}$/;"	f	class:Shape
intersect	GeometryApi.h	/^  intersect(SimpleMPL::Rectangle<T>& rectangle, const SimpleMPL::Rectangle<T>& b, bool consider_touch = true) {$/;"	f	namespace:boost::polygon
kASSERT	Msg.h	/^    kASSERT = 5$/;"	e	enum:MessageType
kDEBUG	Msg.h	/^	kDEBUG = 4, $/;"	e	enum:MessageType
kERROR	Msg.h	/^	kERROR = 3, $/;"	e	enum:MessageType
kINFO	Msg.h	/^	kINFO = 1, $/;"	e	enum:MessageType
kNONE	Msg.h	/^	kNONE = 0, $/;"	e	enum:MessageType
kWARN	Msg.h	/^	kWARN = 2, $/;"	e	enum:MessageType
layer	GdsiiIO.h	/^	int32_t layer;$/;"	m	struct:GdsReader
layer	Shapes.h	/^		int32_t layer() const {return m_layer;}$/;"	f	class:Shape
layer	Shapes.h	/^		void layer(int32_t l) {m_layer = l;}$/;"	f	class:Shape
layoutdb_type	GdsiiIO.h	/^	typedef LayoutDB layoutdb_type;$/;"	t	struct:GdsReader
layoutdb_type	GdsiiIO.h	/^	typedef LayoutDB layoutdb_type;$/;"	t	struct:GdsWriter
layoutdb_type	RecoverHiddenVertex.h	/^        typedef LayoutDB layoutdb_type;$/;"	t	class:RecoverHiddenVertex
layoutdb_type	SimpleMPL.h	/^	typedef LayoutDB layoutdb_type;$/;"	t	class:SimpleMPL
layoutdb_type	stitch/SimpleMPL.h	/^        typedef LayoutDB layoutdb_type;$/;"	t	class:SimpleMPL
layoutdb_type	stitch/StitchProc.h	/^	typedef LayoutDB layoutdb_type;$/;"	t	class:StitchProc
limbo	GeometryApi.h	/^namespace limbo { namespace geometry {$/;"	n
ll	stitch/SimpleMPL.h	/^		QiPoint ll;$/;"	m	struct:QiBox
m_DPL	stitch/StitchProc.h	/^    std::vector<std::vector<uint32_t>> m_DPL;     \/\/ This vector stores the conflict patterns.$/;"	m	class:StitchProc
m_Safe	stitch/StitchProc.h	/^	std::vector<std::vector<uint32_t>> m_Safe;    \/\/ This vector stores the safe patterns.$/;"	m	class:StitchProc
m_Touch	stitch/StitchProc.h	/^    std::vector<std::vector<uint32_t>> m_Touch;   \/\/ This vector is for polygon type data.$/;"	m	class:StitchProc
m_comp_cnt	SimpleMPL.h	/^	uint32_t                  m_comp_cnt;     \/\/\/< max# of connected components$/;"	m	class:SimpleMPL
m_comp_cnt	stitch/SimpleMPL.h	/^        uint32_t                            m_comp_cnt;     \/\/\/< max# of connected components$/;"	m	class:SimpleMPL
m_comp_cnt	stitch/StitchProc.h	/^	uint32_t						m_comp_cnt;$/;"	m	class:StitchProc
m_db	RecoverHiddenVertex.h	/^        layoutdb_type const& m_db;$/;"	m	class:RecoverHiddenVertex
m_db	SimpleMPL.h	/^	layoutdb_type* m_db; \/\/\/< pointer of layout database and user-defined options $/;"	m	class:SimpleMPL
m_db	stitch/SimpleMPL.h	/^        layoutdb_type* m_db; \/\/\/< pointer of layout database and user-defined options $/;"	m	class:SimpleMPL
m_db	stitch/StitchProc.h	/^	layoutdb_type *m_db;$/;"	m	class:StitchProc
m_dg	RecoverHiddenVertex.h	/^        graph_type const& m_dg;$/;"	m	class:RecoverHiddenVertex
m_final_rectangle	stitch/StitchProc.h	/^	std::vector<rectangle_type>		m_final_rectangle;$/;"	m	class:StitchProc
m_interRect	stitch/StitchProc.h	/^	std::vector<std::vector<rectangle_type>> m_interRect;$/;"	m	class:StitchProc
m_internal_id	Shapes.h	/^		long m_internal_id; \/\/\/< internal id $/;"	m	class:Shape
m_itBgn	RecoverHiddenVertex.h	/^        std::vector<uint32_t>::const_iterator m_itBgn;$/;"	m	class:RecoverHiddenVertex
m_layout_down	stitch/StitchProc.h	/^	coordinate_type m_layout_down		= INT32_MAX;$/;"	m	class:StitchProc
m_layout_left	stitch/StitchProc.h	/^	coordinate_type m_layout_left		= INT32_MAX;$/;"	m	class:StitchProc
m_layout_right	stitch/StitchProc.h	/^	coordinate_type m_layout_right		= INT32_MIN;$/;"	m	class:StitchProc
m_layout_top	stitch/StitchProc.h	/^	coordinate_type m_layout_top		= INT32_MIN;$/;"	m	class:StitchProc
m_mAdjVertex	SimpleMPL.h	/^	std::vector<std::vector<uint32_t> > m_mAdjVertex;   \/\/\/< adjcency list$/;"	m	class:SimpleMPL
m_mAdjVertex	stitch/SimpleMPL.h	/^        std::vector<std::vector<uint32_t> > m_mAdjVertex;   \/\/\/< adjcency list$/;"	m	class:SimpleMPL
m_pattern_cnt	RecoverHiddenVertex.h	/^        uint32_t m_pattern_cnt;$/;"	m	class:RecoverHiddenVertex
m_pattern_id	Shapes.h	/^		uint32_t m_pattern_id; \/\/\/< index in the pattern array $/;"	m	class:Shape
m_vColor	RecoverHiddenVertex.h	/^        std::vector<int8_t>& m_vColor;$/;"	m	class:RecoverHiddenVertex
m_vColorDensity	RecoverHiddenVertex.h	/^        std::vector<uint32_t> const& m_vColorDensity;$/;"	m	class:RecoverHiddenVertex::std
m_vColorDensity	SimpleMPL.h	/^	std::vector<uint32_t> m_vColorDensity; \/\/\/< number of colors used so far $/;"	m	class:SimpleMPL
m_vColorDensity	stitch/SimpleMPL.h	/^        std::vector<uint32_t> m_vColorDensity; \/\/\/< number of colors used so far $/;"	m	class:SimpleMPL
m_vCompId	SimpleMPL.h	/^	std::vector<uint32_t>          m_vCompId;      \/\/\/< independent component id$/;"	m	class:SimpleMPL
m_vCompId	stitch/SimpleMPL.h	/^        std::vector<uint32_t>               m_vCompId;      \/\/\/< independent component id$/;"	m	class:SimpleMPL
m_vCompId	stitch/StitchProc.h	/^	std::vector<uint32_t>			m_vCompId;$/;"	m	class:StitchProc
m_vConflict	SimpleMPL.h	/^	mutable std::vector<std::pair<uint32_t, uint32_t> > m_vConflict; \/\/\/< conflict patterns  $/;"	m	class:SimpleMPL
m_vConflict	stitch/SimpleMPL.h	/^        mutable std::vector<std::pair<uint32_t, uint32_t> > m_vConflict; \/\/\/< conflict patterns  $/;"	m	class:SimpleMPL
m_vConflict	stitch/StitchProc.h	/^	mutable std::vector<std::pair<uint32_t, uint32_t> > m_vConflict;$/;"	m	class:StitchProc
m_vDist	RecoverHiddenVertex.h	/^        std::vector<coordinate_difference> m_vDist; \/\/\/< minimum distance for different colors to current vertex $/;"	m	class:RecoverHiddenVertexDistance
m_vHiddenVertices	RecoverHiddenVertex.h	/^        std::stack<vertex_descriptor>& m_vHiddenVertices;$/;"	m	class:RecoverHiddenVertex
m_vUnusedColor	RecoverHiddenVertex.h	/^        std::vector<char> m_vUnusedColor; \/\/\/< local variable to avoid frequent construction$/;"	m	class:RecoverHiddenVertex
m_vVertexOrder	SimpleMPL.h	/^	std::vector<uint32_t>          m_vVertexOrder; \/\/\/< vertex id$/;"	m	class:SimpleMPL
m_vVertexOrder	stitch/SimpleMPL.h	/^        std::vector<uint32_t>               m_vVertexOrder; \/\/\/< vertex id$/;"	m	class:SimpleMPL
m_vVertexOrder	stitch/StitchProc.h	/^	std::vector<uint32_t>				m_vVertexOrder;$/;"	m	class:StitchProc
m_value	Enums.h	/^        EnumType m_value;$/;"	m	class:EnumExt
main	main.cpp	/^int main(int argc, char** argv)$/;"	f
mplAssert	Msg.h	53;"	d
mplAssertMsg	Msg.h	46;"	d
mplPrint	Msg.cpp	/^int mplPrint(MessageType m, const char* format, ...)$/;"	f
mplPrintAssertMsg	Msg.cpp	/^void mplPrintAssertMsg(const char* expr, const char* fileName, unsigned lineNum, const char* funcName)$/;"	f
mplPrintAssertMsg	Msg.cpp	/^void mplPrintAssertMsg(const char* expr, const char* fileName, unsigned lineNum, const char* funcName, const char* format, ...)$/;"	f
mplPrintStream	Msg.cpp	/^int mplPrintStream(MessageType m, FILE* stream, const char* format, ...)$/;"	f
mplSPrint	Msg.cpp	/^int mplSPrint(MessageType m, char* buf, const char* format, ...)$/;"	f
mplSPrintPrefix	Msg.cpp	/^int mplSPrintPrefix(MessageType m, char* prefix)$/;"	f
mplStaticAssert	Msg.h	/^    mplStaticAssert(const char* = NULL) {}$/;"	f	struct:mplStaticAssert
mplStaticAssert	Msg.h	/^struct mplStaticAssert<true> $/;"	s
mplVPrintStream	Msg.cpp	/^int mplVPrintStream(MessageType m, FILE* stream, const char* format, va_list args)$/;"	f
mplVSPrint	Msg.cpp	/^int mplVSPrint(MessageType m, char* buf, const char* format, va_list args)$/;"	f
new2ori	SimpleMPL.h	/^	std::vector<uint32_t> new2ori;		\/\/ store the mapping relationships from new patterns back to original patterns.$/;"	m	class:SimpleMPL
new2ori	stitch/SimpleMPL.h	/^		std::vector<uint32_t>	new2ori;	\/\/ store the mapping relationships from new patterns back to original patterns.$/;"	m	class:SimpleMPL
operator !=	Enums.h	/^		bool operator!=(EnumExt const& rhs) const {return m_value != rhs.m_value;}$/;"	f	class:EnumExt
operator !=	Enums.h	/^		bool operator!=(enum_type const& rhs) const {return m_value != rhs;}$/;"	f	class:EnumExt
operator !=	Enums.h	/^		bool operator!=(std::string const& rhs) const {return *this != EnumExt(rhs);}$/;"	f	class:EnumExt
operator ()	GdsiiIO.cpp	/^bool GdsReader::operator() (std::string const& filename)  $/;"	f	class:GdsReader
operator ()	GdsiiIO.cpp	/^void GdsWriter::operator() (std::string const& filename, GdsWriter::layoutdb_type const& db, $/;"	f	class:GdsWriter
operator ()	GeometryApi.h	/^    result_type operator()(V const& v) const { return *v; }$/;"	f	struct:boost::geometry::index::indexable
operator ()	LayoutDB.h	/^		bool operator() (rectangle_pointer_type const& r1, rectangle_pointer_type const& r2) const$/;"	f	struct:LayoutDB::compare_rectangle_type
operator ()	LayoutDB.h	/^		bool operator() (rectangle_type const& r1, rectangle_type const& r2) const$/;"	f	struct:LayoutDB::compare_rectangle_type
operator ()	Params.cpp	/^bool CmdParser::operator()(int argc, char** argv)$/;"	f	class:CmdParser
operator ()	RecoverHiddenVertex.cpp	/^void RecoverHiddenVertex::operator()()$/;"	f	class:RecoverHiddenVertex
operator <<	Enums.h	/^		friend std::ostream& operator<<(std::ostream& os, const EnumExt& rhs)$/;"	f	class:EnumExt
operator <<	Shapes.h	/^		friend std::ostream& operator<<(std::ostream& os, Polygon const& rhs)$/;"	f	class:Polygon
operator <<	Shapes.h	/^		friend std::ostream& operator<<(std::ostream& os, Rectangle const& rhs)$/;"	f	class:Rectangle
operator =	Enums.h	/^		AlgorithmType& operator=(AlgorithmType const& rhs)$/;"	f	class:AlgorithmType
operator =	Enums.h	/^		AlgorithmType& operator=(enum_type const& rhs)$/;"	f	class:AlgorithmType
operator =	Enums.h	/^		AlgorithmType& operator=(std::string const& rhs)$/;"	f	class:AlgorithmType
operator =	Enums.h	/^		EnumExt& operator=(EnumExt const& rhs)$/;"	f	class:EnumExt
operator =	Enums.h	/^		EnumExt& operator=(enum_type const& rhs)$/;"	f	class:EnumExt
operator =	Enums.h	/^		EnumExt& operator=(std::string const& rhs)$/;"	f	class:EnumExt
operator =	Enums.h	/^		ShapeMode& operator=(ShapeMode const& rhs)$/;"	f	class:ShapeMode
operator =	Enums.h	/^		ShapeMode& operator=(enum_type const& rhs)$/;"	f	class:ShapeMode
operator =	Enums.h	/^		ShapeMode& operator=(std::string const& rhs)$/;"	f	class:ShapeMode
operator =	LayoutDB.cpp	/^LayoutDB& LayoutDB::operator=(LayoutDB const& rhs)$/;"	f	class:LayoutDB
operator =	LayoutDBPolygon.cpp	/^LayoutDBPolygon& LayoutDBPolygon::operator=(LayoutDBPolygon const& rhs)$/;"	f	class:LayoutDBPolygon
operator =	LayoutDBRect.cpp	/^LayoutDBRect& LayoutDBRect::operator=(LayoutDBRect const& rhs)$/;"	f	class:LayoutDBRect
operator =	Shapes.h	/^		Polygon& operator=(Polygon const& rhs)$/;"	f	class:Polygon
operator =	Shapes.h	/^		Rectangle& operator=(Rectangle const& rhs)$/;"	f	class:Rectangle
operator =	Shapes.h	/^		Shape& operator=(Shape const& rhs)$/;"	f	class:Shape
operator ==	Enums.h	/^		bool operator==(EnumExt const& rhs) const {return m_value == rhs.m_value;}$/;"	f	class:EnumExt
operator ==	Enums.h	/^		bool operator==(enum_type const& rhs) const {return m_value == rhs;}$/;"	f	class:EnumExt
operator ==	Enums.h	/^		bool operator==(std::string const& rhs) const {return *this == EnumExt(rhs);}$/;"	f	class:EnumExt
operator std::string	Enums.h	/^		virtual operator std::string() const$/;"	f	class:EnumExt
operator std::string	Shapes.h	/^        operator std::string() const $/;"	f	class:Polygon
operator std::string	Shapes.h	/^        operator std::string() const $/;"	f	class:Rectangle
output_gds	LayoutDB.h	/^    inline std::string const& output_gds() const {return parms.output_gds;}$/;"	f	class:LayoutDB::std
output_gds	Params.h	/^	std::string   output_gds;                  \/\/\/< output gdsii filename $/;"	m	struct:ControlParameter
parms	LayoutDB.h	/^	ControlParameter parms; \/\/\/< control parameters from command line$/;"	m	struct:LayoutDB
parms	Params.h	/^	ControlParameter& parms;$/;"	m	struct:CmdParser
path_type	GdsiiIO.h	/^	typedef layoutdb_type::path_type               path_type;$/;"	t	struct:GdsReader
path_type	GdsiiIO.h	/^	typedef layoutdb_type::path_type path_type;$/;"	t	struct:GdsWriter
path_type	LayoutDB.h	/^	typedef segment_data<coordinate_type> path_type;$/;"	t	struct:LayoutDB
path_type	SimpleMPL.h	/^	typedef layoutdb_type::path_type               path_type;$/;"	t	class:SimpleMPL
path_type	stitch/SimpleMPL.h	/^        typedef layoutdb_type::path_type               path_type;$/;"	t	class:SimpleMPL
path_type	stitch/StitchProc.h	/^	typedef layoutdb_type::path_type               path_type;$/;"	t	class:StitchProc
pattern_bboxes	LayoutDB.h	/^	virtual std::vector<rectangle_pointer_type> const& pattern_bboxes() const { return vPatternBbox; }$/;"	f	class:LayoutDB::std
pattern_id	Shapes.h	/^		uint32_t pattern_id() const {return m_pattern_id;}$/;"	f	class:Shape
pattern_id	Shapes.h	/^		void pattern_id(uint32_t p) {m_pattern_id = p;}$/;"	f	class:Shape
point_type	GdsiiIO.h	/^	typedef layoutdb_type::point_type              point_type;$/;"	t	struct:GdsReader
point_type	GdsiiIO.h	/^	typedef layoutdb_type::point_type point_type;$/;"	t	struct:GdsWriter
point_type	GeometryApi.h	/^struct point_type<SimpleMPL::Rectangle<CoordinateType> >$/;"	s	namespace:boost::geometry::traits
point_type	LayoutDB.h	/^	typedef point_data<coordinate_type> point_type;$/;"	t	struct:LayoutDB
point_type	RecoverHiddenVertex.h	/^        typedef layoutdb_type::point_type              point_type;$/;"	t	class:RecoverHiddenVertex
point_type	Shapes.h	/^		typedef point_data<coordinate_type> point_type;$/;"	t	class:Polygon
point_type	Shapes.h	/^		typedef point_data<coordinate_type> point_type;$/;"	t	class:Rectangle
point_type	SimpleMPL.h	/^	typedef layoutdb_type::point_type              point_type;$/;"	t	class:SimpleMPL
point_type	stitch/SimpleMPL.h	/^        typedef layoutdb_type::point_type              point_type;$/;"	t	class:SimpleMPL
point_type	stitch/StitchProc.h	/^	typedef layoutdb_type::point_type              point_type;$/;"	t	class:StitchProc
polygon	GeometryApi.h	/^namespace boost { namespace polygon {$/;"	n	namespace:boost
polygon	Shapes.h	/^namespace boost { namespace polygon {$/;"	n	namespace:boost
polygon_pointer_type	GdsiiIO.h	/^	typedef layoutdb_type::polygon_pointer_type    polygon_pointer_type;$/;"	t	struct:GdsReader
polygon_pointer_type	GdsiiIO.h	/^	typedef layoutdb_type::polygon_pointer_type polygon_pointer_type;$/;"	t	struct:GdsWriter
polygon_pointer_type	LayoutDB.h	/^	typedef polygon_type* polygon_pointer_type;$/;"	t	struct:LayoutDB
polygon_pointer_type	SimpleMPL.h	/^	typedef layoutdb_type::polygon_pointer_type    polygon_pointer_type;$/;"	t	class:SimpleMPL
polygon_pointer_type	stitch/SimpleMPL.h	/^        typedef layoutdb_type::polygon_pointer_type    polygon_pointer_type;$/;"	t	class:SimpleMPL
polygon_pointer_type	stitch/StitchProc.h	/^	typedef layoutdb_type::polygon_pointer_type    polygon_pointer_type;$/;"	t	class:StitchProc
polygon_set_type	LayoutDB.h	/^	typedef polygon_90_set_data<coordinate_type> polygon_set_type;$/;"	t	struct:LayoutDB
polygon_type	GdsiiIO.h	/^	typedef layoutdb_type::polygon_type            polygon_type;$/;"	t	struct:GdsReader
polygon_type	GdsiiIO.h	/^	typedef layoutdb_type::polygon_type polygon_type;$/;"	t	struct:GdsWriter
polygon_type	LayoutDB.h	/^	typedef Polygon<coordinate_type> polygon_type;$/;"	t	struct:LayoutDB
polygon_type	SimpleMPL.h	/^	typedef layoutdb_type::polygon_type            polygon_type;$/;"	t	class:SimpleMPL
polygon_type	stitch/SimpleMPL.h	/^        typedef layoutdb_type::polygon_type            polygon_type;$/;"	t	class:SimpleMPL
polygon_type	stitch/StitchProc.h	/^	typedef layoutdb_type::polygon_type            polygon_type;$/;"	t	class:StitchProc
polyrectBgnId	LayoutDBPolygon.h	/^	virtual std::vector<uint32_t> const& polyrectBgnId() const { return vPolyRectBeginId; }$/;"	f	class:LayoutDBPolygon::std
polyrectBgnId	LayoutDBRect.h	/^	virtual std::vector<uint32_t> const& polyrectBgnId() const { std::vector<uint32_t> m; return m; }$/;"	f	class:LayoutDBRect::std
polyrect_patterns	LayoutDBPolygon.h	/^    virtual std::vector<rectangle_pointer_type> const& polyrect_patterns() const {return vPolyRectPattern;}$/;"	f	class:LayoutDBPolygon::std
polyrect_patterns	LayoutDBRect.h	/^    virtual std::vector<rectangle_pointer_type> const& polyrect_patterns() const {return vPatternBbox;}$/;"	f	class:LayoutDBRect::std
print	Enums.h	/^		virtual void print(std::ostream& os) const {os << this->enum2Str(m_value);}$/;"	f	class:EnumExt
print	Shapes.h	/^        void print(std::ostream& os) const $/;"	f	class:Rectangle
print	Shapes.h	/^        void print(std::ostream& os) const$/;"	f	class:Polygon
print_welcome	SimpleMPL.cpp	/^void SimpleMPL::print_welcome() const$/;"	f	class:SimpleMPL
print_welcome	stitch/SimpleMPL.cpp	/^void SimpleMPL::print_welcome() const$/;"	f	class:SimpleMPL
projection	SimpleMPL.cpp	/^void SimpleMPL::projection(rectangle_type & pRect, std::vector<rectangle_pointer_type>& split, std::vector<rectangle_pointer_type> nei_Vec)$/;"	f	class:SimpleMPL
projection	stitch/StitchProc.cpp	/^void StitchProc::projection()$/;"	f	class:StitchProc
read_cmd	SimpleMPL.cpp	/^void SimpleMPL::read_cmd(int32_t argc, char** argv)$/;"	f	class:SimpleMPL
read_cmd	stitch/SimpleMPL.cpp	/^void SimpleMPL::read_cmd(int argc, char** argv)$/;"	f	class:SimpleMPL
read_cmd	stitch/StitchProc.cpp	/^void StitchProc::read_cmd(int argc, char** argv)$/;"	f	class:StitchProc
read_gds	SimpleMPL.cpp	/^void SimpleMPL::read_gds()$/;"	f	class:SimpleMPL
read_gds	stitch/SimpleMPL.cpp	/^void SimpleMPL::read_gds()$/;"	f	class:SimpleMPL
read_gds	stitch/StitchProc.cpp	/^void StitchProc::read_gds()$/;"	f	class:StitchProc
real_4_cbk	GdsiiIO.cpp	/^void GdsReader::real_4_cbk(GdsParser::GdsRecords::EnumType record_type, GdsParser::GdsData::EnumType data_type, std::vector<double> const& vFloat) $/;"	f	class:GdsReader
real_8_cbk	GdsiiIO.cpp	/^void GdsReader::real_8_cbk(GdsParser::GdsRecords::EnumType record_type, GdsParser::GdsData::EnumType data_type, std::vector<double> const& vFloat) $/;"	f	class:GdsReader
recover_vertex	RecoverHiddenVertex.cpp	/^void RecoverHiddenVertex::recover_vertex(RecoverHiddenVertex::vertex_descriptor v)$/;"	f	class:RecoverHiddenVertex
rectangle_pointer_type	GdsiiIO.h	/^	typedef layoutdb_type::rectangle_pointer_type  rectangle_pointer_type;$/;"	t	struct:GdsReader
rectangle_pointer_type	GdsiiIO.h	/^	typedef layoutdb_type::rectangle_pointer_type rectangle_pointer_type;$/;"	t	struct:GdsWriter
rectangle_pointer_type	LayoutDB.h	/^	typedef rectangle_type* rectangle_pointer_type;$/;"	t	struct:LayoutDB
rectangle_pointer_type	RecoverHiddenVertex.h	/^        typedef layoutdb_type::rectangle_pointer_type  rectangle_pointer_type;$/;"	t	class:RecoverHiddenVertex
rectangle_pointer_type	SimpleMPL.h	/^	typedef layoutdb_type::rectangle_pointer_type  rectangle_pointer_type;$/;"	t	class:SimpleMPL
rectangle_pointer_type	stitch/SimpleMPL.h	/^        typedef layoutdb_type::rectangle_pointer_type  rectangle_pointer_type;$/;"	t	class:SimpleMPL
rectangle_pointer_type	stitch/StitchProc.h	/^	typedef layoutdb_type::rectangle_pointer_type  rectangle_pointer_type;$/;"	t	class:StitchProc
rectangle_traits	GeometryApi.h	/^struct rectangle_traits<SimpleMPL::Rectangle<T> >\/\/ : public rectangle_traits<boost::polygon::rectangle_data<T> >$/;"	s	namespace:limbo::geometry
rectangle_type	GdsiiIO.h	/^	typedef layoutdb_type::rectangle_type          rectangle_type;$/;"	t	struct:GdsReader
rectangle_type	GdsiiIO.h	/^	typedef layoutdb_type::rectangle_type rectangle_type;$/;"	t	struct:GdsWriter
rectangle_type	GeometryApi.h	/^	typedef SimpleMPL::Rectangle<coordinate_type> rectangle_type;$/;"	t	struct:limbo::geometry::rectangle_traits
rectangle_type	LayoutDB.h	/^	typedef Rectangle<coordinate_type> rectangle_type;$/;"	t	struct:LayoutDB
rectangle_type	RecoverHiddenVertex.h	/^        typedef layoutdb_type::rectangle_type          rectangle_type;$/;"	t	class:RecoverHiddenVertex
rectangle_type	Shapes.h	/^		typedef Rectangle<coordinate_type> rectangle_type;$/;"	t	class:Polygon
rectangle_type	SimpleMPL.h	/^	typedef layoutdb_type::rectangle_type          rectangle_type;$/;"	t	class:SimpleMPL
rectangle_type	stitch/SimpleMPL.h	/^        typedef layoutdb_type::rectangle_type          rectangle_type;$/;"	t	class:SimpleMPL
rectangle_type	stitch/StitchProc.h	/^	typedef layoutdb_type::rectangle_type          rectangle_type;$/;"	t	class:StitchProc
relation4rect	stitch/StitchProc.cpp	/^void StitchProc::relation4rect()$/;"	f	class:StitchProc
remove_overlap	LayoutDB.cpp	/^void LayoutDB::remove_overlap(std::vector<LayoutDB::rectangle_pointer_type>& vTargetPattern)$/;"	f	class:LayoutDB
report	SimpleMPL.cpp	/^void SimpleMPL::report() const$/;"	f	class:SimpleMPL
report	stitch/SimpleMPL.cpp	/^void SimpleMPL::report() const $/;"	f	class:SimpleMPL
report_data	LayoutDBPolygon.cpp	/^void LayoutDBPolygon::report_data() const $/;"	f	class:LayoutDBPolygon
report_data	LayoutDBRect.cpp	/^void LayoutDBRect::report_data() const $/;"	f	class:LayoutDBRect
report_data_kernel	LayoutDB.cpp	/^void LayoutDB::report_data_kernel() const$/;"	f	class:LayoutDB
report_data_kernel	LayoutDBPolygon.cpp	/^void LayoutDBPolygon::report_data_kernel() const $/;"	f	class:LayoutDBPolygon
reset	SimpleMPL.cpp	/^void SimpleMPL::reset(bool init)$/;"	f	class:SimpleMPL
reset	stitch/SimpleMPL.cpp	/^void SimpleMPL::reset(bool init)$/;"	f	class:SimpleMPL
reset	stitch/StitchProc.cpp	/^void StitchProc::reset(bool init)$/;"	f	class:StitchProc
result_type	GeometryApi.h	/^    typedef Box const& result_type;$/;"	t	struct:boost::geometry::index::indexable
rtree_type	LayoutDB.h	/^	typedef bgi::rtree<rectangle_pointer_type, bgi::rstar<16> > rtree_type;$/;"	t	struct:LayoutDB
rtree_type	SimpleMPL.h	/^	typedef layoutdb_type::rtree_type              rtree_type;$/;"	t	class:SimpleMPL
rtree_type	stitch/SimpleMPL.h	/^        typedef layoutdb_type::rtree_type              rtree_type;$/;"	t	class:SimpleMPL
rtree_type	stitch/StitchProc.h	/^	typedef layoutdb_type::rtree_type              rtree_type;$/;"	t	class:StitchProc
run	SimpleMPL.cpp	/^void SimpleMPL::run(int32_t argc, char** argv)$/;"	f	class:SimpleMPL
run	stitch/SimpleMPL.cpp	/^void SimpleMPL::run(int argc, char** argv)$/;"	f	class:SimpleMPL
runProjection	SimpleMPL.cpp	/^void SimpleMPL::runProjection()$/;"	f	class:SimpleMPL
sPathLayer	Params.h	/^	std::set<int32_t> sPathLayer;              \/\/\/< path layers that represent conflict edges $/;"	m	struct:ControlParameter
sPrecolorLayer	Params.h	/^	std::set<int32_t> sPrecolorLayer;          \/\/\/< layers that represent precolored features, they should have the same number of colors $/;"	m	struct:ControlParameter
sUncolorLayer	Params.h	/^	std::set<int32_t> sUncolorLayer;           \/\/\/< layers that represent uncolored patterns $/;"	m	struct:ControlParameter
set	GeometryApi.h	/^	static void set(typename rectangle_type::base_type& rect, direction_2d const& dir, coordinate_type const& value) $/;"	f	struct:limbo::geometry::rectangle_traits
set_color	LayoutDBPolygon.cpp	/^void LayoutDBPolygon::set_color(uint32_t pattern_id, int8_t color)$/;"	f	class:LayoutDBPolygon
set_color	LayoutDBRect.cpp	/^void LayoutDBRect::set_color(uint32_t pattern_id, int8_t color)$/;"	f	class:LayoutDBRect
shape_base_type	Shapes.h	/^        typedef Shape shape_base_type;$/;"	t	class:Polygon
shape_base_type	Shapes.h	/^        typedef Shape shape_base_type;$/;"	t	class:Rectangle
shape_mode	LayoutDB.h	/^    inline ShapeMode shape_mode() const {return parms.shape_mode;}$/;"	f	struct:LayoutDB
shape_mode	Params.h	/^    ShapeMode shape_mode;                      \/\/\/< it determins the actual derived layout database type $/;"	m	struct:ControlParameter
simplify_level	LayoutDB.h	/^	inline int32_t simplify_level() const { return parms.simplify_level; }$/;"	f	struct:LayoutDB
simplify_level	Params.h	/^	int32_t simplify_level;                    \/\/\/< simplification level 0|1|2|3, default is 3$/;"	m	struct:ControlParameter
solve	SimpleMPL.cpp	/^void SimpleMPL::solve()$/;"	f	class:SimpleMPL
solve	stitch/SimpleMPL.cpp	/^void SimpleMPL::solve()$/;"	f	class:SimpleMPL
solve_component	SimpleMPL.cpp	/^uint32_t SimpleMPL::solve_component(const std::vector<uint32_t>::const_iterator itBgn, const std::vector<uint32_t>::const_iterator itEnd, uint32_t comp_id)$/;"	f	class:SimpleMPL
solve_component	stitch/SimpleMPL.cpp	/^uint32_t SimpleMPL::solve_component(const std::vector<uint32_t>::const_iterator itBgn, const std::vector<uint32_t>::const_iterator itEnd, uint32_t comp_id)$/;"	f	class:SimpleMPL
solve_graph_coloring	SimpleMPL.cpp	/^uint32_t SimpleMPL::solve_graph_coloring(uint32_t comp_id, SimpleMPL::graph_type const& dg,$/;"	f	class:SimpleMPL
solve_graph_coloring	stitch/SimpleMPL.cpp	/^uint32_t SimpleMPL::solve_graph_coloring(uint32_t comp_id, SimpleMPL::graph_type const& dg, $/;"	f	class:SimpleMPL
status	GdsiiIO.h	/^    GdsParser::GdsRecords::EnumType status; $/;"	m	struct:GdsReader
stitch_solve	SimpleMPL.cpp	/^void SimpleMPL::stitch_solve()$/;"	f	class:SimpleMPL
str2Enum	Enums.cpp	/^AlgorithmType::enum_type AlgorithmType::str2Enum(std::string const& s) const$/;"	f	class:AlgorithmType
str2Enum	Enums.cpp	/^ShapeMode::enum_type ShapeMode::str2Enum(std::string const& s) const$/;"	f	class:ShapeMode
string_cbk	GdsiiIO.cpp	/^void GdsReader::string_cbk(GdsParser::GdsRecords::EnumType record_type, GdsParser::GdsData::EnumType data_type, std::string const& str) $/;"	f	class:GdsReader
strname	LayoutDB.h	/^	std::string strname;                            \/\/\/< TOPCELL name, useful for dump out gds files $/;"	m	struct:LayoutDB
swap	Params.h	/^inline void ControlParameter::swap(ControlParameter& rhs)$/;"	f	class:ControlParameter
tPatternBbox	LayoutDB.h	/^	rtree_type tPatternBbox;                       \/\/\/< rtree for components that intersects the LayoutDB$/;"	m	struct:LayoutDB
tag	GeometryApi.h	/^struct tag<SimpleMPL::Rectangle<CoordinateType> > : public tag<typename SimpleMPL::Rectangle<CoordinateType>::base_type>$/;"	s	namespace:boost::geometry::traits
thread_num	LayoutDB.h	/^	inline int32_t thread_num() const { return parms.thread_num; }$/;"	f	struct:LayoutDB
thread_num	Params.h	/^	int32_t thread_num;                        \/\/\/< number of maximum threads for parallel computation $/;"	m	struct:ControlParameter
traits	GeometryApi.h	/^namespace boost { namespace geometry { namespace traits {$/;"	n	namespace:boost::geometry
type	GeometryApi.h	/^	typedef rectangle_concept type;$/;"	t	struct:boost::polygon::geometry_concept
type	GeometryApi.h	/^    typedef typename SimpleMPL::Rectangle<CoordinateType>::point_type type;$/;"	t	struct:boost::geometry::traits::point_type
unit	LayoutDB.h	/^	double unit;                               \/\/\/< keep output gdsii file has the same unit as input gdsii file $/;"	m	struct:LayoutDB
update_bbox	LayoutDB.cpp	/^void LayoutDB::update_bbox(base_type const& bbox)$/;"	f	class:LayoutDB
ur	stitch/SimpleMPL.h	/^		QiPoint ur;$/;"	m	struct:QiBox
use_stitch	LayoutDB.h	/^	inline bool use_stitch() const { return parms.use_stitch; }$/;"	f	struct:LayoutDB
use_stitch	Params.h	/^	bool use_stitch;						   \/\/\/< control whether stitches are used in coloring $/;"	m	struct:ControlParameter
vLP1HalfInteger	SimpleMPL.cpp	/^std::vector<unsigned int> vLP1HalfInteger;$/;"	v
vLP1HalfInteger	stitch/SimpleMPL.cpp	/^std::vector<unsigned int> vLP1HalfInteger; $/;"	v
vLP1NonInteger	SimpleMPL.cpp	/^std::vector<unsigned int> vLP1NonInteger;$/;"	v
vLP1NonInteger	stitch/SimpleMPL.cpp	/^std::vector<unsigned int> vLP1NonInteger; $/;"	v
vLP2HalfInteger	SimpleMPL.cpp	/^std::vector<unsigned int> vLP2HalfInteger;$/;"	v
vLP2HalfInteger	stitch/SimpleMPL.cpp	/^std::vector<unsigned int> vLP2HalfInteger; $/;"	v
vLP2NonInteger	SimpleMPL.cpp	/^std::vector<unsigned int> vLP2NonInteger;$/;"	v
vLP2NonInteger	stitch/SimpleMPL.cpp	/^std::vector<unsigned int> vLP2NonInteger; $/;"	v
vLPEndHalfInteger	SimpleMPL.cpp	/^std::vector<unsigned int> vLPEndHalfInteger;$/;"	v
vLPEndHalfInteger	stitch/SimpleMPL.cpp	/^std::vector<unsigned int> vLPEndHalfInteger; $/;"	v
vLPEndNonInteger	SimpleMPL.cpp	/^std::vector<unsigned int> vLPEndNonInteger;$/;"	v
vLPEndNonInteger	stitch/SimpleMPL.cpp	/^std::vector<unsigned int> vLPEndNonInteger; $/;"	v
vLPNumIter	SimpleMPL.cpp	/^std::vector<unsigned int> vLPNumIter;$/;"	v
vLPNumIter	stitch/SimpleMPL.cpp	/^std::vector<unsigned int> vLPNumIter; $/;"	v
vParentPolygonId	LayoutDBPolygon.h	/^    std::vector<uint32_t> vParentPolygonId; \/\/\/< no need to actually store polygon patterns as we stored decomposed rectangles $/;"	m	struct:LayoutDBPolygon
vPatternBbox	LayoutDB.h	/^	std::vector<rectangle_pointer_type> vPatternBbox;   \/\/\/< uncolored and precolored patterns $/;"	m	struct:LayoutDB
vPoint	GdsiiIO.h	/^    std::vector<point_type> vPoint;$/;"	m	struct:GdsReader
vPolyRectBeginId	LayoutDBPolygon.h	/^    std::vector<uint32_t> vPolyRectBeginId; \/\/\/< begin index in vPolyRectPattern when querying from parent polygon id $/;"	m	struct:LayoutDBPolygon
vPolyRectPattern	LayoutDBPolygon.h	/^    std::vector<rectangle_pointer_type> vPolyRectPattern; \/\/\/< initial patterns decomposed from input polygons $/;"	m	struct:LayoutDBPolygon
verbose	LayoutDB.h	/^	inline bool verbose() const { return parms.verbose; }$/;"	f	struct:LayoutDB
verbose	Params.h	/^	bool verbose;                              \/\/\/< control screen message $/;"	m	struct:ControlParameter
vertex_descriptor	LayoutDB.h	/^	typedef boost::graph_traits<graph_type>::vertex_descriptor vertex_descriptor;$/;"	t	struct:LayoutDB
vertex_descriptor	RecoverHiddenVertex.h	/^        typedef layoutdb_type::vertex_descriptor       vertex_descriptor;$/;"	t	class:RecoverHiddenVertex
vertex_descriptor	SimpleMPL.h	/^	typedef layoutdb_type::vertex_descriptor       vertex_descriptor;$/;"	t	class:SimpleMPL
vertex_descriptor	stitch/SimpleMPL.h	/^        typedef layoutdb_type::vertex_descriptor       vertex_descriptor;$/;"	t	class:SimpleMPL
vertex_descriptor	stitch/StitchProc.h	/^	typedef layoutdb_type::vertex_descriptor       vertex_descriptor;$/;"	t	class:StitchProc
whetherHor	stitch/StitchProc.cpp	/^bool StitchProc::whetherHor(rectangle_pointer_type tmp)$/;"	f	class:StitchProc
whetherHorizontal	SimpleMPL.cpp	/^bool SimpleMPL::whetherHorizontal(rectangle_type temp)$/;"	f	class:SimpleMPL
write_conflicts	GdsiiIO.cpp	/^void GdsWriter::write_conflicts(GdsParser::GdsWriter& gw, GdsWriter::layoutdb_type const& db, $/;"	f	class:GdsWriter
write_edges	GdsiiIO.cpp	/^void GdsWriter::write_edges(GdsParser::GdsWriter& gw, GdsWriter::layoutdb_type const& db, std::vector<std::vector<uint32_t> > const& mAdjVertex, const int32_t layer) const $/;"	f	class:GdsWriter
write_gds	SimpleMPL.cpp	/^void SimpleMPL::write_gds()$/;"	f	class:SimpleMPL
write_gds	stitch/SimpleMPL.cpp	/^void SimpleMPL::write_gds()$/;"	f	class:SimpleMPL
write_gds	stitch/StitchProc.cpp	/^void StitchProc::write_gds()$/;"	f	class:StitchProc
write_graph	SimpleMPL.cpp	/^void SimpleMPL::write_graph(SimpleMPL::graph_type& g, std::string const& filename) const$/;"	f	class:SimpleMPL
write_graph	stitch/SimpleMPL.cpp	/^void SimpleMPL::write_graph(SimpleMPL::graph_type& g, std::string const& filename) const$/;"	f	class:SimpleMPL
write_intermediate	GdsiiIO.cpp	/^void GdsWriter::write_intermediate(std::string const& filename, std::vector<GdsWriter::rectangle_pointer_type> const& vRect, const int32_t layer_offset, std::string const& strname, double unit) const$/;"	f	class:GdsWriter
write_paths	GdsiiIO.cpp	/^void GdsWriter::write_paths(GdsParser::GdsWriter& gw, std::map<int32_t, std::vector<GdsWriter::path_type> > const& hPath) const $/;"	f	class:GdsWriter
write_rectangles	GdsiiIO.cpp	/^void GdsWriter::write_rectangles(GdsParser::GdsWriter& gw, std::vector<GdsWriter::rectangle_pointer_type> const& vRect, const int32_t layer_offset) const $/;"	f	class:GdsWriter
x	stitch/SimpleMPL.h	/^		int x, y;$/;"	m	struct:QiPoint
y	stitch/SimpleMPL.h	/^		int x, y;$/;"	m	struct:QiPoint
~LayoutDB	LayoutDB.cpp	/^LayoutDB::~LayoutDB()$/;"	f	class:LayoutDB
~LayoutDBPolygon	LayoutDBPolygon.cpp	/^LayoutDBPolygon::~LayoutDBPolygon()$/;"	f	class:LayoutDBPolygon
~LayoutDBRect	LayoutDBRect.cpp	/^LayoutDBRect::~LayoutDBRect()$/;"	f	class:LayoutDBRect
~Polygon	Shapes.h	/^		~Polygon() {}$/;"	f	class:Polygon
~RecoverHiddenVertex	RecoverHiddenVertex.h	/^        virtual ~RecoverHiddenVertex() {}$/;"	f	class:RecoverHiddenVertex
~Rectangle	Shapes.h	/^		~Rectangle() {}$/;"	f	class:Rectangle
~Shape	Shapes.h	/^		~Shape() {}$/;"	f	class:Shape
~SimpleMPL	SimpleMPL.cpp	/^SimpleMPL::~SimpleMPL()$/;"	f	class:SimpleMPL
~SimpleMPL	stitch/SimpleMPL.cpp	/^SimpleMPL::~SimpleMPL()$/;"	f	class:SimpleMPL
~StitchProc	stitch/StitchProc.cpp	/^StitchProc::~StitchProc()$/;"	f	class:StitchProc
